# 41243256
# 41243215
## 解題說明
實作排序n個數字的函式，包含以下：  
Insertion Sort  
Quick Sort(Median-of-Three)  
Merge Sort(Iterative)  
Heap Sort  
  
專門為每個排序建立最壞情況資料產生器：   
Insertion Sort：反向排序[n, n-1, n-2, ... , 1]  
Quick Sort(Median-of-Three)：將排序邏輯反轉，逆推出 worst-case  
Merge Sort(Iterative)：隨機產生並保留需排序最久的測試資料  
Heap Sort：隨機產生並保留需排序最久的測試資料  
  
計算每個排序函式的執行時間和記憶體，並繪製圖表  
計算排序法的時間複雜度，並與測試結果進行比對，確認結果是否正確  
最後根據以上四種排序查看圖表在n多少時使用何種排序最快，寫出一個合成排序  
### 解題策略
1. 我們可以先寫出四種排序的程式並透過題目提供的隨機排序產生器進行測試
2. 確認四種排序都能進行正常運作後就能開始寫最壞情況資料產生器
3. 將原先的隨機排序產生器改寫成題目要求的最壞情況資料產生器
4. 確認最壞情況資料產生器輸入給四種排序後大致符合預期輸出
5. 透過Windows API檢測記憶體占用，最後檢查是否大致符合預期輸出
## 效能分析
### 時間複雜度(最壞情況)  
   1. Insertion Sort：O($n^{2}$)   
      完全逆序時，每插入一個新元素，都要向前比對並移動所有已有元素，  
      第1次比較1次，第2次比較2次，…，第n-1次比較n-1次，  
      所以總比較次數是：1+2+3+⋯+(n−1)  
      總時間複雜度變成O($n^{2}$)  
   2. Quick Sort(Median-of-Three)：O($n^{2}$)   
      資料經過特別設計（像幾乎一樣大、排列特別的資料），  
      仍然可能讓每次劃分非常不平均（例如一邊有n-1個元素，另一邊0個元素）  
      這樣遞迴深度變成 n 層，每層處理 O(n) 個元素，  
      總時間複雜度變成O($n^{2}$)  
     
   4. Merge Sort(Iterative)：O(n log n)	  
      分成 log n 層（因為每次切半，直到每個元素單獨一個）  
      每層合併時，要遍歷所有 n 個元素來合併，  
      所以總時間是O(n log n)  
        
   5. Heap Sort：O(n log n)  
      建堆（heapify）整體需要 O(n) 時間  
      每次取最大元素並重建堆，需要 O(log n) 時間  
      要取 n 次元素（每次刪除堆頂），  
      所以總時間是O(n log n)
### 空間複雜度
   1. Insertion Sort：O(1)  
      插入排序直接在原陣列上進行排序，只需要一點點暫存空間（例如存暫時拿出來的元素）  
      不需要額外開大範圍的記憶體，屬於原地排序（in-place），  
      所以空間複雜度是O(1)  

   2. Quick Sort(Median-of-Three)：O(log n)  
      快速排序本身是原地排序（只靠交換元素），但遞迴呼叫需要額外的堆疊空間，  
      每層遞迴最多是 log n 層，  
      所以空間複雜度是O(log n)

   3. Merge Sort(Iterative)：O(n)
      合併排序需要開一個暫存陣列來合併子陣列，  
      這個暫存陣列通常大小是 O(n)，即跟原始資料一樣大，
      所以空間複雜度是O(n)

   4. Heap Sort：O(1)
      堆積排序是直接在原陣列上調整堆結構，  
      不需要額外開大範圍的記憶體，只需要少數變數暫存交換，  
      所以空間複雜度是O(1)    
## 程式實作

## 測試與驗證

## 申論及開發報告
